import React from 'react';
import {SectionList, StyleSheet, View} from 'react-native';
import {Text} from "react-native-elements";

const Transcript = (props) => {
  const transcript = [
    {
      title: 'Course Overview',
      data: [
        {
          subTitle: 'Course Overview',
          content: '[Autogenerated] E everyone. My name is Matt Soca and welcome to my course developing mobile applications protected by Azure Active Directory. I\'m a principal at Code Mel Technologies, and I\'ve been building mobile labs ever since. There was an APP store, and ever since then, one thing hasn\'t changed. Authentication is essential to mobile applications. Your users need to be able to sign in and access protected Resource is in a secure way from a black ops. Azure active directory gives you incredible versatility and creating identity enabled mobile applications. In this course, we\'re going to learn how to set up as your active directory to support mobile lamps and all the constituent parts that support Sign in and authenticate the custom Web AP eyes that you or your developers may have built to retrieve protected data. Grasp the fundamentals of Microsoft graph and learn how to get your mobile app to query and uses powerful framework and hot. Create native Loggins so you can create pixel perfect Sinan screens. By the end of this course, you\'ll have the skills and knowledge to build identity enabled mobile applications with azure active directory Before beginning this course, you should be familiar with the basics of azure active directory and mobile development will be using xamarin, but the concepts are broad and will apply to all frameworks. I hope you\'ll join me on this journey to learn how to develop mobile APS integrated with identity with the developing mobile applications protected by Azure Active Directory Course AP Plural Site.'
        }
      ]
    },
    {
      title: 'Understanding Azure Active Directory Mobile Applications',
      data: [
        {
          subTitle: 'Course Introduction',
          content: '[Autogenerated] Hello, friends and welcome to developing mobile applications protected by Azure Active Directory. My name is Matt Soak up, and I\'m a principal at Code Male Technologies, and my Twitter handle is code mailman. I\'ve been developing mobile applications ever since the original Iowa\'s Apstar opened, and the one thing that has remained constant from then until now is the need. Tohave users of mobile APS access protected resource is azure. Active Directory gives you incredible versatility and building identity enabled mobile APS, and in this course you\'ll learn the tools and techniques of developing mobile apse with Asher Active Directory. In this course, you will learn how to develop mobile applications that interface with azure active directory so they can obtain secure data from Azure. Resource is, you\'ll learn how to sign users and by sitting up what are known as azure 80 applications and the Microsoft Authentication Library. And users will be able to sign in with their work and school accounts or their personal Microsoft that counts, and all two factor authentication will work right on the box. Once signed in, you\'ll learn how to use the return tokens. The Access Web AP Eyes hosted in Asher and you\'ll even learn how to manipulate your users. Microsoft based data like Microsoft 3 65 Data using Microsoft graph A great example of that is creating meetings on a user\'s calendar and being able to read those meetings, too. And, of course, you learn the insides of how this all works in this course developing mobile applications protected by Azure Active Directory, you\'re going to cover a lot of ground in this course. Some of the things that you\'ll learn include the fundamentals of what mobile APS mean in the context of azure active directory that will give you the building blocks for learning to build an app that can authenticate and access secured data from a custom Web, a p I. You\'ll also learn about Microsoft graph, which is an extremely powerful A P I that allows developers to query and modify users Microsoft Account and Microsoft 3 65 information like creating calendar appointments. Brokered applications are supported by Azure Active Directory and his client S D case. Brokered authentication enables a whole host of neat features such a single sign on by using an app like Microsoft Authenticator. Then you\'ll learn how to create your own log in screens, bypassing the Web based ones that as your 80 provides. But even more importantly, you\'ll find out why signing in users this way may not be the best idea. Throughout this course, it\'s assumed that you\'ll have a basic working knowledge of azure, active directory and authentication concepts and familiarity with building mobile applications. This module is all about understanding how azure active directory or as your A D is all sometimes abbreviated models, your mobile app. First, you\'ll learn about the authentication flow that most mobile app Siew\'s when signing users and and then retrieving secured data from an A P I. Then you\'ll dive a little deeper and break down the parts of that flow and see how portions of it correspond a azure 80 concepts for mobile applications.'
        },
        {
          subTitle: 'Mobile Authentication Flow',
          content: '[Autogenerated] There are four entities involved in the most common type of mobile app. Authentication with Asher A. D, and everything starts with the user tapping log in. What that\'s going to do is pop up a system Web view. That browser is going to communicate to the authorization and point of azure active directory. It\'s going to send a bunch of info over things like the application i D. Some scopes, an indication that wants an authorization code in return and the policy wants to execute the end point will oblige and have the user complete the policy, whatever that maybe it could be completing a user name and password or more, including two factor authentication. The credentials then get sent back to the end point and, assuming everything checks out. An authorization code, then gets sent back to the system Web view the Web viewed, then returns that authorization code back to the mobile app, and then it closes. Next up, the APP needs to get a token so it can access some protective Resource is so what it does is invoke another endpoint on Azure a d. The token endpoint. It sends a lot of the same info that it did when making their quest to the authorization and point. But it also sends along the authorization code itself, and it indicates that it wants an O up bearer token or access token in return. That endpoint then returns the access token along with a refresh token, be APC in, then make a request to a Web. AP I that\'s protected by Azure a. D. It will send across the access token. It just got in the authorization headers of the http request and all that hard work finally pays off. Then when the Web AP I returns the secure data, this flow has a technical name, and that\'s O off 2.0 authorization code grant flow. Now, what about that refresh token, which has also returned with the access token? What is it good for? The access token has a short lifespan before it is no longer valid, and a mobile app can use a refresh token to request the new access token without prompting the user to sign in again. This is a code of how that works. The mobile apple maker requests to their token endpoint of azure A D. It\'ll send the refresh token, along with other appropriate info to identify what type of access token it needs. That end point will return to new access token along with the new refresh token, at which point the access token could be used in the http authorization Headers for a request to a Web, A P I and Secure data comes back, so notice from the four entities from before the Web you and the authorization endpoint do not come into play. Those entities require user interaction to get for. And since one of the defining traits of refresh tokens is to obtain access tokens without user interaction, the Web view and authorization and point are not needed.'
        }
      ]
    }
  ]

  const SubTranScript = (props) => {
    return <View>
      <Text h4 style={{paddingVertical: 5}}>{props.item.subTitle}</Text>
      <Text style={{marginBottom: 20}}>{props.item.content}</Text>
    </View>
  }
  return <SectionList
    sections={transcript}
    keyExtractor={(item, index) => item + index}
    renderItem={({item}) =>
      <SubTranScript item={item}/>
    }
    renderSectionHeader={({section: {title}}) => <Text h3 >{title}</Text>}
  />
};
export default Transcript;
